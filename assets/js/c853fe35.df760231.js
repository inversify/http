"use strict";(self.webpackChunk_inversifyjs_inversify_http_docs_site=self.webpackChunk_inversifyjs_inversify_http_docs_site||[]).push([["386"],{2220:function(e,n,r){r.r(n),r.d(n,{frontMatter:()=>h,toc:()=>x,default:()=>g,metadata:()=>t,assets:()=>f,contentTitle:()=>m});var t=JSON.parse('{"id":"fundamentals/controller","title":"Controller","description":"Controllers are classes annotated with the @Controller() decorator. They group request handlers for a feature area. A controller defines a base path and one or more route handlers using method decorators.","source":"@site/docs/fundamentals/controller.mdx","sourceDirName":"fundamentals","slug":"/fundamentals/controller","permalink":"/http/docs/fundamentals/controller","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Controller"},"sidebar":"tutorialSidebar","previous":{"title":"Getting started","permalink":"/http/docs/introduction/getting-started"},"next":{"title":"Error Filter","permalink":"/http/docs/fundamentals/error-filter"}}'),s=r(9970),o=r(7245),a=r(6184),l=r(3270),i=r(6174),c=r(9594),d=r(7021),u=r(6121),p=r(3546);let h={sidebar_position:1,title:"Controller"},m="Controller",f={},x=[{value:"Basic example",id:"basic-example",level:2},{value:"Registering a controller",id:"registering-a-controller",level:2},{value:"Implementation approaches",id:"implementation-approaches",level:2},{value:"1. Non-native types (Recommended)",id:"1-non-native-types-recommended",level:3},{value:"2. Native types (Advanced)",id:"2-native-types-advanced",level:3}];function v(e){let n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"controller",children:"Controller"})}),"\n",(0,s.jsxs)(n.p,{children:["Controllers are classes annotated with the ",(0,s.jsx)(n.code,{children:"@Controller()"})," decorator. They group request handlers for a feature area. A controller defines a base path and one or more route handlers using ",(0,s.jsx)(n.a,{href:"../../api/decorators/#http-methods",children:"method decorators"}),"."]}),"\n",(0,s.jsx)(n.admonition,{title:"Controller and injectable decorators",type:"info",children:(0,s.jsxs)(n.p,{children:["You don't need to add ",(0,s.jsx)(n.code,{children:"@injectable()"}),". The ",(0,s.jsx)(n.code,{children:"@Controller()"})," decorator already applies it for you."]})}),"\n",(0,s.jsx)(n.h2,{id:"basic-example",children:"Basic example"}),"\n",(0,s.jsx)(n.p,{children:"A minimal controller with one route:"}),"\n",(0,s.jsx)(d.A,{language:"ts",children:"@Controller('/messages')\nexport class MessagesController {\n  @Get('/hello')\n  public async sayHello(): Promise<Message> {\n    return { content: 'world' };\n  }\n}"}),"\n",(0,s.jsx)(n.h2,{id:"registering-a-controller",children:"Registering a controller"}),"\n",(0,s.jsx)(n.p,{children:"Register controllers in your container. Bind your controller class and choose a scope."}),"\n",(0,s.jsx)(d.A,{language:"ts",children:"const container: Container = new Container();\n// Register the controller so the adapter can discover it\ncontainer.bind(MessagesController).toSelf().inSingletonScope();"}),"\n",(0,s.jsxs)(n.p,{children:["When you call ",(0,s.jsx)(n.code,{children:"build()"})," on your server adapter, it builds routes from controller metadata at runtime."]}),"\n",(0,s.jsx)(n.h2,{id:"implementation-approaches",children:"Implementation approaches"}),"\n",(0,s.jsx)(n.p,{children:"There are two complementary ways to write controller routes in Inversify HTTP. You can keep your handlers framework-agnostic and let Inversify send the response for you, or you can opt into native adapter types and take full control of the underlying framework's response flow."}),"\n",(0,s.jsx)(n.h3,{id:"1-non-native-types-recommended",children:"1. Non-native types (Recommended)"}),"\n",(0,s.jsxs)(n.p,{children:["With the framework-agnostic approach, your controller methods return values and Inversify converts them into HTTP responses. The adapter decides how to shape the response based on the value: strings are sent as plain text, objects (including undefined) are sent as JSON, Node streams are piped as streaming responses, and primitive values like numbers or booleans are stringified as text. The status code is 200 by default, but you can override it per route with the ",(0,s.jsx)(n.code,{children:"@StatusCode()"})," decorator or by returning a typed ",(0,s.jsx)(n.code,{children:"HttpResponse"})," (for example, ",(0,s.jsx)(n.code,{children:"new CreatedHttpResponse(body)"})," or throwing an ",(0,s.jsx)(n.code,{children:"ErrorHttpResponse"}),"). This keeps controllers portable across adapters and focuses them on business logic rather than framework details."]}),"\n",(0,s.jsx)(d.A,{language:"ts",children:"@Controller('/users')\nexport class NonNativeUsersController {\n  // Return plain value - Inversify converts to JSON response\n  @Get()\n  @SetHeader('X-Custom-Header', 'CustomValue')\n  public async getUsers(): Promise<User[]> {\n    return [\n      { email: 'john@example.com', id: 1, name: 'John Doe' },\n      { email: 'jane@example.com', id: 2, name: 'Jane Smith' },\n    ];\n  }\n\n  // Return specific HttpResponse for custom status codes\n  @Post()\n  public async createUser(\n    @Body() userData: CreateUserRequest,\n  ): Promise<CreatedHttpResponse> {\n    const newUser: User = {\n      email: userData.email,\n      id: Math.random(),\n      name: userData.name,\n    };\n\n    return new CreatedHttpResponse(newUser);\n  }\n\n  // Throw ErrorHttpResponse for error conditions\n  @Get('/not-found')\n  public async getUserNotFound(): Promise<never> {\n    throw new ErrorHttpResponse(\n      HttpStatusCode.NOT_FOUND,\n      'User not found',\n      'The requested user does not exist',\n    );\n  }\n\n  // Return string directly - sent as text response\n  @Get('/status')\n  public async getStatus(): Promise<string> {\n    return 'Service is healthy';\n  }\n}"}),"\n",(0,s.jsx)(n.h3,{id:"2-native-types-advanced",children:"2. Native types (Advanced)"}),"\n",(0,s.jsxs)(n.p,{children:["If you need direct access to adapter features, inject native types with ",(0,s.jsx)(n.code,{children:"@Response()"})," and ",(0,s.jsx)(n.code,{children:"@Next()"}),". In this mode you're responsible for the full response lifecycle: setting headers, choosing the status code, sending the body (or streaming), and deciding whether to call ",(0,s.jsx)(n.code,{children:"next()"})," to continue the pipeline. This trades portability for full control and is useful for advanced scenarios like fine-grained caching headers, streaming, or integrating with middleware that expects native objects."]}),"\n",(0,s.jsx)(n.p,{children:"Usage with different adapters:"}),"\n",(0,s.jsxs)(u.A,{children:[(0,s.jsx)(p.A,{value:"express4",label:"Express 4",children:(0,s.jsx)(d.A,{language:"ts",children:a})}),(0,s.jsx)(p.A,{value:"express5",label:"Express 5",children:(0,s.jsx)(d.A,{language:"ts",children:l})}),(0,s.jsx)(p.A,{value:"fastify",label:"Fastify",children:(0,s.jsx)(d.A,{language:"ts",children:i})}),(0,s.jsx)(p.A,{value:"hono",label:"Hono",children:(0,s.jsx)(d.A,{language:"ts",children:c})})]}),"\n",(0,s.jsx)(n.admonition,{title:"When to use native types",type:"tip",children:(0,s.jsx)(n.p,{children:"Reach for native types when you need precise control over the HTTP exchange\u2014streaming large payloads, fine-tuning caching and headers, squeezing out adapter-specific performance, or interoperating with middleware that expects a native response object. For most routes, the framework-agnostic approach remains simpler, more portable, and easier to test."})}),"\n",(0,s.jsx)(n.admonition,{title:"Important: Choose one approach per route",type:"warning",children:(0,s.jsxs)(n.p,{children:["Avoid mixing modes within the same route. If you inject ",(0,s.jsx)(n.code,{children:"@Response()"})," or ",(0,s.jsx)(n.code,{children:"@Next()"}),", your handler should manage the response entirely and typically return ",(0,s.jsx)(n.code,{children:"void"})," (or the framework ",(0,s.jsx)(n.code,{children:"Response"})," for Hono). Conversely, when you return values for Inversify to send, don't also write to the native response object."]})})]})}function g(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(v,{...e})}):v(e)}},3270:function(e){e.exports="@Controller('/message')\nexport class ResponseExpressController {\n  @Get()\n  public async sendMessage(\n    @Response() response: express.Response,\n  ): Promise<void> {\n    response.send({ message: 'hello' });\n  }\n}\n"},6184:function(e){e.exports="@Controller('/message')\nexport class ResponseExpressController {\n  @Get()\n  public async sendMessage(\n    @Response() response: express.Response,\n  ): Promise<void> {\n    response.send({ message: 'hello' });\n  }\n}\n"},6174:function(e){e.exports="@Controller('/message')\nexport class ResponseFastifyController {\n  @Get()\n  public async sendMessage(@Response() reply: FastifyReply): Promise<void> {\n    reply.send({ message: 'hello' });\n  }\n}\n"},9594:function(e){e.exports="import { Controller, Get } from '@inversifyjs/http-core';\nimport { Context } from '@inversifyjs/http-hono';\nimport { Context as HonoContext } from 'hono';\n\n@Controller('/message')\nexport class ResponseHonoController {\n  @Get()\n  public async sendMessage(@Context() context: HonoContext): Promise<Response> {\n    return context.json({ message: 'hello' });\n  }\n}\n"},3546:function(e,n,r){r.d(n,{A:()=>o});var t=r(9970);r(2714);var s=r(929);function o({children:e,hidden:n,className:r}){return(0,t.jsx)("div",{role:"tabpanel",className:(0,s.A)("tabItem_y91D",r),hidden:n,children:e})}},6121:function(e,n,r){r.d(n,{A:()=>g});var t=r(9970),s=r(2714),o=r(929),a=r(760),l=r(5455),i=r(2090),c=r(773),d=r(1834),u=r(9575);function p(e){return s.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){let{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h({value:e,tabValues:n}){return n.some(n=>n.value===e)}var m=r(6290);function f({className:e,block:n,selectedValue:r,selectValue:s,tabValues:l}){let i=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.a_)(),d=e=>{let n=e.currentTarget,t=l[i.indexOf(n)].value;t!==r&&(c(n),s(t))},u=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{let r=i.indexOf(e.currentTarget)+1;n=i[r]??i[0];break}case"ArrowLeft":{let r=i.indexOf(e.currentTarget)-1;n=i[r]??i[i.length-1]}}n?.focus()};return(0,t.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.A)("tabs",{"tabs--block":n},e),children:l.map(({value:e,label:n,attributes:s})=>(0,t.jsx)("li",{role:"tab",tabIndex:r===e?0:-1,"aria-selected":r===e,ref:e=>{i.push(e)},onKeyDown:u,onClick:d,...s,className:(0,o.A)("tabs__item","tabItem_NOJ1",s?.className,{"tabs__item--active":r===e}),children:n??e},e))})}function x({lazy:e,children:n,selectedValue:r}){let a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){let e=a.find(e=>e.props.value===r);return e?(0,s.cloneElement)(e,{className:(0,o.A)("margin-top--md",e.props.className)}):null}return(0,t.jsx)("div",{className:"margin-top--md",children:a.map((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==r}))})}function v(e){let n=function(e){let n,{defaultValue:r,queryString:t=!1,groupId:o}=e,a=function(e){let{values:n,children:r}=e;return(0,s.useMemo)(()=>{let e=n??p(r).map(({props:{value:e,label:n,attributes:r,default:t}})=>({value:e,label:n,attributes:r,default:t})),t=(0,d.XI)(e,(e,n)=>e.value===n.value);if(t.length>0)throw Error(`Docusaurus error: Duplicate values "${t.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`);return e},[n,r])}(e),[m,f]=(0,s.useState)(()=>(function({defaultValue:e,tabValues:n}){if(0===n.length)throw Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!h({value:e,tabValues:n}))throw Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}let r=n.find(e=>e.default)??n[0];if(!r)throw Error("Unexpected error: 0 tabValues");return r.value})({defaultValue:r,tabValues:a})),[x,v]=function({queryString:e=!1,groupId:n}){let r=(0,l.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,c.aZ)(t),(0,s.useCallback)(e=>{if(!t)return;let n=new URLSearchParams(r.location.search);n.set(t,e),r.replace({...r.location,search:n.toString()})},[t,r])]}({queryString:t,groupId:o}),[g,y]=function({groupId:e}){let n=e?`docusaurus.tab.${e}`:null,[r,t]=(0,u.Dv)(n);return[r,(0,s.useCallback)(e=>{n&&t.set(e)},[n,t])]}({groupId:o}),b=h({value:n=x??g,tabValues:a})?n:null;return(0,i.A)(()=>{b&&f(b)},[b]),{selectedValue:m,selectValue:(0,s.useCallback)(e=>{if(!h({value:e,tabValues:a}))throw Error(`Can't select invalid tab value=${e}`);f(e),v(e),y(e)},[v,y,a]),tabValues:a}}(e);return(0,t.jsxs)("div",{className:(0,o.A)("tabs-container","tabList_r3Dk"),children:[(0,t.jsx)(f,{...n,...e}),(0,t.jsx)(x,{...n,...e})]})}function g(e){let n=(0,m.A)();return(0,t.jsx)(v,{...e,children:p(e.children)},String(n))}}}]);